}
}
colnames(design.mat) <- col_names
for(i in seq(nstudy)){
studytx <- Treat[(end.Study[i]+1):end.Study[i+1]]  #treatments in ith Study
nonbase.tx <- studytx[studytx!=base.tx[i]]    #non-baseline treatments for ith Study
for (j in seq(length(nonbase.tx))){
design.mat[j+rows[i],paste0("Treat", base.tx[i], nonbase.tx[j])] <- 1
}
}
design.mat
Treat
for (i in seq(nstudy)){
studytx <- Treat[(end.Study[i]+1):end.Study[i+1]]  #treatments in ith Study
nonbase.tx <- studytx[studytx!=base.tx[i]]    #non-baseline treatments for ith Study
design.mat[(1+rows[i]):rows[i+1],base.tx[i]] <- -1
for (j in seq(length(nonbase.tx)))
design.mat[j+rows[i],nonbase.tx[j]] <- 1
}
design.mat <- design.mat[,-1,drop=F]
design.mat
y <- delta
# design matrix
base.tx <- Treat[b.id]    # base treatment for N studies
end.Study <- c(0, cumsum(na))  # end row number of each trial
rows <- end.Study - seq(0, nstudy)   # end number of each trial not including base treatment arms
design.mat <- matrix(0, sum(na) - nstudy, ntreat) # no. non-base arms x #txs
for (i in seq(nstudy)){
studytx <- Treat[(end.Study[i]+1):end.Study[i+1]]  #treatments in ith Study
nonbase.tx <- studytx[studytx!=base.tx[i]]    #non-baseline treatments for ith Study
design.mat[(1+rows[i]):rows[i+1],base.tx[i]] <- -1
for (j in seq(length(nonbase.tx)))
design.mat[j+rows[i],nonbase.tx[j]] <- 1
}
design.mat
# dependent variable for regression
y <- delta
# design matrix
base.tx <- Treat[b.id]    # base treatment for N studies
end.Study <- c(0, cumsum(na))  # end row number of each trial
rows <- end.Study - seq(0, nstudy)   # end number of each trial not including base treatment arms
design.mat <- matrix(0, sum(na) - nstudy, ntreat*(ntreat-1)/2 ) # no. non-base arms x #txs
col_names <- NULL
for(i in 1:(ntreat-1)){
for(j in (i+1):ntreat){
col_names <- c(col_names, paste0("Treat", i, j))
}
}
colnames(design.mat) <- col_names
for(i in seq(nstudy)){
studytx <- Treat[(end.Study[i]+1):end.Study[i+1]]  #treatments in ith Study
nonbase.tx <- studytx[studytx!=base.tx[i]]    #non-baseline treatments for ith Study
for (j in seq(length(nonbase.tx))){
design.mat[j+rows[i],paste0("Treat", base.tx[i], nonbase.tx[j])] <- 1
}
}
fit <- summary(lm(y ~ design.mat - 1))
d <- se.d <- rep(NA, ntreat)
fit <- summary(lm(y ~ design.mat - 1))
d <- se.d <- rep(NA, ntreat)
d[-1] <- coef(fit)[,1]
se.d[-1] <- coef(fit)[,2]
resid.var <- fit$sigma^2
delta
# dependent variable for regression
y <- delta
fit <- summary(lm(y ~ design.mat - 1))
delta
y
design.mat
ume.binomial.inits(network, 3)
ume.binomial.inits <- function(network, n.chains){
with(network,{
Outcomes <- Outcomes + 0.5 # ensure ratios are always defined
N <- N + 1
p <- Outcomes/N
logits <- log(p/(1-p))
se.logits <- sqrt(1/Outcomes + 1/(N - Outcomes))
mu <- logits[b.id]
se.mu <- se.logits[b.id]
delta <- logits - rep(mu, times = na)
delta <- delta[!b.id,]
inits = ume.make.inits(network, n.chains, delta, mu, se.mu)
return(inits)
})
}
ume.binomial.inits(network, 3)
ume.binomial.inits(network, 3  with(network,{
Outcomes <- Outcomes + 0.5 # ensure ratios are always defined
N <- N + 1
p <- Outcomes/N
logits <- log(p/(1-p))
se.logits <- sqrt(1/Outcomes + 1/(N - Outcomes))
mu <- logits[b.id]
se.mu <- se.logits[b.id]
delta <- logits - rep(mu, times = na)
delta <- delta[!b.id,]
delta}))
with(network,{
Outcomes <- Outcomes + 0.5 # ensure ratios are always defined
N <- N + 1
p <- Outcomes/N
logits <- log(p/(1-p))
se.logits <- sqrt(1/Outcomes + 1/(N - Outcomes))
mu <- logits[b.id]
se.mu <- se.logits[b.id]
delta <- logits - rep(mu, times = na)
delta <- delta[!b.id,]
delta})
delta <-   with(network,{
Outcomes <- Outcomes + 0.5 # ensure ratios are always defined
N <- N + 1
p <- Outcomes/N
logits <- log(p/(1-p))
se.logits <- sqrt(1/Outcomes + 1/(N - Outcomes))
mu <- logits[b.id]
se.mu <- se.logits[b.id]
delta <- logits - rep(mu, times = na)
delta <- delta[!b.id,]
delta})
delta
y <- delta
# design matrix
base.tx <- Treat[b.id]    # base treatment for N studies
end.Study <- c(0, cumsum(na))  # end row number of each trial
rows <- end.Study - seq(0, nstudy)   # end number of each trial not including base treatment arms
design.mat <- matrix(0, sum(na) - nstudy, ntreat*(ntreat-1)/2 ) # no. non-base arms x #txs
col_names <- NULL
for(i in 1:(ntreat-1)){
for(j in (i+1):ntreat){
col_names <- c(col_names, paste0("Treat", i, j))
}
}
colnames(design.mat) <- col_names
for(i in seq(nstudy)){
studytx <- Treat[(end.Study[i]+1):end.Study[i+1]]  #treatments in ith Study
nonbase.tx <- studytx[studytx!=base.tx[i]]    #non-baseline treatments for ith Study
for (j in seq(length(nonbase.tx))){
design.mat[j+rows[i],paste0("Treat", base.tx[i], nonbase.tx[j])] <- 1
}
}
fit <- summary(lm(y ~ design.mat - 1))
d <- se.d <- rep(NA, ntreat)
d[-1] <- coef(fit)[,1]
se.d[-1] <- coef(fit)[,2]
resid.var <- fit$sigma^2
coef(fit)
coef(fit)[,1]
d
d <- se.d <- rep(NA, ntreat*(ntreat-1)/2)
d[-1] <- coef(fit)[,1]
se.d[-1] <- coef(fit)[,2]
d <- se.d <- rep(NA, ntreat*(ntreat-1)/2)
d
coef(fit)[,1]
d <- coef(fit)[,1]
se.d <- coef(fit)[,2]
resid.var <- fit$sigma^2
upper.tri(d.matrix) <- d
d.matrix <- matrix(NA, nrow = ntreat, nrow = ntreat)
upper.tri(d.matrix) <- d
ntreat
d.matrix <- matrix(NA, nrow = ntreat, ncol = ntreat)
upper.tri(d.matrix) <- d
upper.tri(d.matrix)
d.matrix[upper.tri(d.matrix)]
d.matrix[upper.tri(d.matrix)] <- d
d.matrix
d
help(upper.tri)
t(d.matrix[upper.tri(d.matrix)])
d.matrix[upper.tri(d.matrix), byRow = TRUE]
d.matrix[upper.tri(d.matrix)]
help(matrix)
d.matrix[upper.tri(d.matrix), byRow = TRUE]
upper.tri(d.matrix)
as.matrix(d.matrix[upper.tri(d.matrix)])
as.matrix(d.matrix[upper.tri(d.matrix)], byrow = TRUE)
d.matrix[upper.tri(d.matrix), byrow = TRUE]
d.matrix[upper.tri(d.matrix)]
for(j in 2:ntreat){
for(i in (j-1):(ntreat-1)){
col_names <- c(col_names, paste0("Treat", i, j))
}
}
col_names
# design matrix
base.tx <- Treat[b.id]    # base treatment for N studies
end.Study <- c(0, cumsum(na))  # end row number of each trial
rows <- end.Study - seq(0, nstudy)   # end number of each trial not including base treatment arms
design.mat <- matrix(0, sum(na) - nstudy, ntreat*(ntreat-1)/2 ) # no. non-base arms x #txs
col_names <- NULL
for(j in 2:ntreat){
for(i in (j-1):(ntreat-1)){
col_names <- c(col_names, paste0("Treat", i, j))
}
}
col_names
col_names <- NULL
for(j in 2:ntreat){
for(i in 1:(j-1)){
col_names <- c(col_names, paste0("Treat", i, j))
}
}
col_names
y <- delta
# design matrix
base.tx <- Treat[b.id]    # base treatment for N studies
end.Study <- c(0, cumsum(na))  # end row number of each trial
rows <- end.Study - seq(0, nstudy)   # end number of each trial not including base treatment arms
design.mat <- matrix(0, sum(na) - nstudy, ntreat*(ntreat-1)/2 ) # no. non-base arms x #txs
col_names <- NULL
for(j in 2:ntreat){
for(i in 1:(j-1)){
col_names <- c(col_names, paste0("Treat", i, j))
}
}
colnames(design.mat) <- col_names
for(i in seq(nstudy)){
studytx <- Treat[(end.Study[i]+1):end.Study[i+1]]  #treatments in ith Study
nonbase.tx <- studytx[studytx!=base.tx[i]]    #non-baseline treatments for ith Study
for (j in seq(length(nonbase.tx))){
design.mat[j+rows[i],paste0("Treat", base.tx[i], nonbase.tx[j])] <- 1
}
}
design.mat
d.matrix <- matrix(NA, nrow = ntreat, ncol = ntreat)
d.matrix[upper.tri(d.matrix)] <- d
d.matrix
d
for(i in seq(nstudy)){
studytx <- Treat[(end.Study[i]+1):end.Study[i+1]]  #treatments in ith Study
nonbase.tx <- studytx[studytx!=base.tx[i]]    #non-baseline treatments for ith Study
for (j in seq(length(nonbase.tx))){
design.mat[j+rows[i],paste0("Treat", base.tx[i], nonbase.tx[j])] <- 1
}
}
fit <- summary(lm(y ~ design.mat - 1))
d <- se.d <- rep(NA, ntreat*(ntreat-1)/2)
d <- coef(fit)[,1]
se.d <- coef(fit)[,2]
resid.var <- fit$sigma^2
d
d.matrix <- matrix(NA, nrow = ntreat, ncol = ntreat)
d.matrix[upper.tri(d.matrix)] <- d
d.matrix
d
df <- fit$df[2]
random.ISigma <- rchisq(1, df)
sigma2 <- resid.var * df/random.ISigma
sigma2
cat(network$code)
d
d.matrix
d
d.matrix
t
network$type
network$t
d.matrix
delta = matrix(NA, nrow = nrow(t), ncol = ncol(t))
for(j in 2:ncol(delta)){
for(ii in 1:nrow(delta)){
if(!is.na(d.matrix[t[ii, 1], t[ii, j]])) delta[ii,j] = rnorm(1, mean = d.matrix[t[ii, 1], t[ii, j]], sd = sqrt(sigma2))
}
}
t <- network$t
delta = matrix(NA, nrow = nrow(t), ncol = ncol(t))
for(j in 2:ncol(delta)){
for(ii in 1:nrow(delta)){
if(!is.na(d.matrix[t[ii, 1], t[ii, j]])) delta[ii,j] = rnorm(1, mean = d.matrix[t[ii, 1], t[ii, j]], sd = sqrt(sigma2))
}
}
delta
remove(list = ls(0))
remove(list = ls())
library(devtools)
install_github("MikeJSeo/network-meta", force = TRUE)
library(mcnet)
library(devtools)
install_github("MikeJSeo/network-meta", force = TRUE)
library(mcnet)
network <- with(smoking, {
network.data(Outcomes, Study, Treat, N = N, response = "binomial", type = "random")
})
result <- network.run(network, n.run = 100000)
library(devtools)
install_github("MikeJSeo/network-meta", force = TRUE)
library(mcnet)
network <- with(smoking, {
ume.network.data(Outcomes, Study, Treat, N = N, response = "binomial", type = "random")
})
result <- ume.network.run(network, n.run = 100000, inits = inits)
result <- ume.network.run(network, n.run = 100000)
result$inits
library(devtools)
install_github("MikeJSeo/network-meta", force = TRUE)
library(mcnet)
library(devtools)
install_github("MikeJSeo/network-meta", force = TRUE)
library(mcnet)
network <- with(smoking, {
ume.network.data(Outcomes, Study, Treat, N = N, response = "binomial", type = "random")
})
result <- ume.network.run(network, n.run = 10000)
Treat
network$Treat
result$inits
network$t
network <- with(smoking, {
ume.network.data(Outcomes, Study, Treat, N = N, response = "binomial", type = "random")
})
result <- ume.network.run(network, n.run = 10000)
summary(result)
network <- with(smoking, {
network.data(Outcomes, Study, Treat, N = N, response = "binomial", type = "random")
})
result <- network.run(network, n.run = 10000)
network <- with(thrombolytic, {
network.data(Outcomes, Study, Treat, N = N, response = "binomial", type = "fixed")
})
result <- network.run(network)
summary(result)
network <- with(thrombolytic, {
ume.network.data(Outcomes, Study, Treat, N = N, response = "binomial", type = "fixed")
})
result <- ume.network.run(network)
Outcomes <- network$Outcomes + 0.5
N <- network$N + 1
p <- Outcomes/N
logits <- log(p/(1-p))
se.logits <- sqrt(1/Outcomes + 1/(N - Outcomes))
b.id <- network$b.id
mu <- logits[b.id]
se.mu <- se.logits[b.id]
delta <- logits - rep(mu, times = na)
na <- network$na
delta <- logits - rep(mu, times = na)
delta <- delta[!b.id,]
# dependent variable for regression
y <- delta
Treat <- network$Treat
Treat
# design matrix
base.tx <- Treat[b.id]    # base treatment for N studies
end.Study <- c(0, cumsum(na))  # end row number of each trial
end.Study
rows <- end.Study - seq(0, nstudy)   # end number of each trial not including base treatment arms
nstudy <- network$nstudy
nstudy
# design matrix
base.tx <- Treat[b.id]    # base treatment for N studies
end.Study <- c(0, cumsum(na))  # end row number of each trial
rows <- end.Study - seq(0, nstudy)   # end number of each trial not including base treatment arms
design.mat <- matrix(0, sum(na) - nstudy, ntreat*(ntreat-1)/2 ) # no. non-base arms x #txs
ntreat <- network$ntreat
ntreat
ntreat*(ntreat-1)/2
design.mat <- matrix(0, sum(na) - nstudy, ntreat*(ntreat-1)/2 ) # no. non-base arms x #txs
col_names <- NULL
for(j in 2:ntreat){
for(i in 1:(j-1)){
col_names <- c(col_names, paste0("Treat", i, j))
}
}
colnames(design.mat) <- col_names
design.mat
for(i in seq(nstudy)){
studytx <- Treat[(end.Study[i]+1):end.Study[i+1]]  #treatments in ith Study
nonbase.tx <- studytx[studytx!=base.tx[i]]    #non-baseline treatments for ith Study
for (j in seq(length(nonbase.tx))){
design.mat[j+rows[i],paste0("Treat", base.tx[i], nonbase.tx[j])] <- 1
}
}
design.mat
fit <- summary(lm(y ~ design.mat - 1))
summary(fit)
fit
mu
result$inits
d
fit <- summary(lm(y ~ design.mat - 1))
d <- se.d <- rep(NA, ntreat*(ntreat-1)/2)
d <- coef(fit)[,1]
se.d <- coef(fit)[,2]
resid.var <- fit$sigma^2
d
fit$fstat
fit
d
coef(fit)
length(coef(fit)[,1])
ntreat*(ntreat-1)/2
if(length(coef(fit)[,1]) == length(d))
)
if(length(coef(fit)[,1]) == length(d)) 1
d
d <- se.d <- rep(NA, ntreat*(ntreat-1)/2)
fit
remove(list = ls())
library(devtools)
install_github("MikeJSeo/network-meta", force = TRUE)
library(mcnet)
library(devtools)
install_github("MikeJSeo/network-meta", force = TRUE)
library(mcnet)
network <- with(thrombolytic, {
network.data(Outcomes, Study, Treat, N = N, response = "binomial", type = "fixed")
})
result <- network.run(network)
result$inits
cat(network$code)
network <- with(thrombolytic, {
ume.network.data(Outcomes, Study, Treat, N = N, response = "binomial", type = "fixed")
})
result <- ume.network.run(network)
cat(network$code)
help(any)
library(devtools)
install_github("MikeJSeo/network-meta", force = TRUE)
library(mcnet)
network <- with(smoking, {
network.data(Outcomes, Study, Treat, N = N, response = "binomial", type = "random")
})
result <- network.run(network)
cat(network$code)
setwd("C:/Users/mike/Desktop/Github/network-meta")
devtools::document()
library(rjags)
Outcomes <- c(-1.22, -1.53, -0.7, -2.4, -0.3, -2.6, -1.2, -0.24, -0.59, -0.73, -0.18, -2.2, -2.5, -1.8, -2.1)
SE <- c(0.504, 0.439, 0.282, 0.258, 0.505, 0.510, 0.478, 0.265, 0.354, 0.335, 0.442, 0.197, 0.190, 0.200, 0.250)
Treat <- c(1, 3, 1, 2, 1, 2, 4, 3, 4, 3, 4, 4, 5, 4, 5)
covariate <- c(1,3,4,2,5,6,7)
#covariate <- cbind(c(1,3,4,2,5,6,7), c(1,2,2,2,3,4,5)) #fake covariate
Study <- c(1, 1, 2, 2, 3, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7)
network <- network.data(Outcomes = Outcomes, Treat = Treat, Study = Study, SE = SE, response = "normal", type = "fixed")
cat(network$code)
network <- network.data(Outcomes = Outcomes, Treat = Treat, Study = Study, SE = SE, response = "normal", covariate = covariate, covariate.model = "exchangeable", hy.prior.cov = list("dgamma", 0.001, 0.001))
cat(network$code)
ume.normal.rjags <- function(network){
with(network, {
code <- paste0("model\n{",
"\n\tfor(i in 1:", nstudy, ") {",
"\n\t\tdelta[i,1] <- 0",
"\n\t\tmu[i] ~ dnorm(0,.0001)",
"\n\t\tfor(k in 1:na[i]) {",
"\n\t\t\ttau[i,k] <- 1/pow(se[i,k],2)",
"\n\t\t\tr[i,k] ~ dnorm(theta[i,k], tau[i,k])")
if(type == "fixed"){
code <- paste0(code, "\n\t\t\ttheta <- mu[i] + d[t[i,1], t[i,k]]")
} else if(type == "random"){
code <- paste0(code, "\n\t\t\ttheta <- mu[i] + delta[i,k]")
}
code <- paste0(code,
"\n\t\t\tdev[i,k] <- (r[i,k]-theta[i,k])*(r[i,k]-theta[i,k])*tau[i,k]",
"\n\t\t}",
"\n\t\tresdev[i] <- sum(dev[i,1:na[i]])")
if(type == "random"){
code <- paste0(code, "\n\t\tfor (k in 2:na[i]) {",
"\n\t\t\tdelta[i,k] ~ dnorm(d[t[i,1],t[i,k]], tau)",
"\n\t\t}")
}
code <- paste0(code,
"\n\t}",
"\n\ttotresdev <- sum(resdev[])")
code <- paste0(code,
"\n\tfor(c in 1:", ntreat -1, ") {",
"\n\t\tfor(k in (c+1):", ntreat, ") {",
"\n\t\t\td[c,k] ~ dnorm(", mean.d, ", ", prec.d, ")",
"\n\t\t}",
"\n\t}")
if(type == "random"){
code <- paste0(code, ume.hy.prior.rjags(hy.prior))
}
code <- paste0(code, "\n}")
return(code)
})
}
parkinsons
network <- with(parkinsons, {
ume.network.data(Outcomes, Study, Treat, N = N, response = "normal", type = "random")
})
network <- with(parkinsons, {
ume.network.data(Outcomes, Study, Treat, SE = SE, response = "normal", type = "random")
})
library(devtools)
install_github("MikeJSeo/network-meta", force = TRUE)
library(mcnet)
network <- with(parkinsons, {
ume.network.data(Outcomes, Study, Treat, SE = SE, response = "normal", type = "random")
})
cat(network$code)
network <- with(parkinsons, {
ume.network.data(Outcomes, Study, Treat, SE = SE, response = "normal", type = "random")
})
library(devtools)
install_github("MikeJSeo/network-meta", force = TRUE)
library(mcnet)
result <- ume.network.run(network)
cat(network$code)
network <- with(parkinsons, {
network.data(Outcomes, Study, Treat, SE = SE, response = "normal", type = "random")
})
cat(network$code)
network <- with(smoking, {
network.data(Outcomes, Study, Treat, N = N, response = "binomial", type = "random")
})
cat(network$code)
network <- with(smoking, {
ume.network.data(Outcomes, Study, Treat, N = N, response = "binomial", type = "random")
})
cat(network$code)
